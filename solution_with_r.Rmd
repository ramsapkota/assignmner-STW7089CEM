---
title: "STW7089CEM: Assignment Solution by Ram Sapkota, 2025"
author: Ram Sapkota
---

# Check and try install required packages 
```{r}
if (!require(matlib)) install.packages("matlib", dependencies = TRUE)
if (!require(ggplot2)) install.packages("ggplot2", dependencies = TRUE)
if (!require(rsample)) install.packages("rsample", dependencies = TRUE)
if (!require(reshape2)) install.packages("reshape2", dependencies = TRUE)
if (!requireNamespace("fields", quietly = TRUE)) {
  install.packages("fields")
}
if (!requireNamespace("gridExtra", quietly = TRUE)) {
  install.packages("gridExtra")
}

```
# Load Required Libraries
```{r}
library(matlib)
library(ggplot2)
library(rsample)
library(reshape2)
library(fields)
library(gridExtra)  # For arranging multiple plots
library(dplyr)
```
# Load the given dataset
```{r}
dataset <- read.csv("dataset.csv", header = TRUE)
colnames(dataset) <- c("x1", "x3", "x4", "x5", "x2")
```
# Evaluate structure, types, nulls, ranges
```{r}
## View dataset structure
str(dataset)

## Summary statistics
summary(dataset)

## Check for missing values
colSums(is.na(dataset))

## Check ranges of each variable
apply(dataset, 2, range)

```
# After evaluating dataset, we split into input (X), output (Y), and time (T) and save into respective files

```{r}
# File names to create
files <- c("x.csv", "y.csv", "t.csv")

# Create empty files (or overwrite if they exist)
for (file in files) {
  file.create(file)
}
```
# Transfer data into newly created files
```{r}

# Extract input features: x1, x3, x4, x5
X <- dataset[, c("x1", "x3", "x4", "x5")]

# Extract output variable: x2
Y <- dataset[, "x2", drop = FALSE]

# Create sequential time index
total_rows <- nrow(dataset) # exclude header count
T <- data.frame(t = 1:total_rows)

write.table(X, "x.csv", 
            sep = ",", row.names = FALSE, col.names = TRUE, quote = FALSE)

write.table(Y, "y.csv", 
            sep = ",", row.names = FALSE, col.names = TRUE, quote = FALSE)

write.table(T, "t.csv",
            sep = ",", row.names = FALSE, col.names = TRUE, quote = FALSE)

```
```{r}
length_x <- length(readLines("x.csv"))
length_y <- length(readLines("y.csv"))
length_t <- length(readLines("t.csv"))

cat("Total lines in X.csv:", length_x, "\n")
cat("Total lines in Y.csv:", length_y, "\n")
cat("Total lines in T.csv:", length_t, "\n")
```
# Task 1.1 : Time Series Plot(of input and output signal)
```{r}
plot_gradient_ts <- function(ts_data, ylab, main, xlab = "", color_palette = c("blue", "red")) {
  n <- length(ts_data)
  x <- 1:n

  # Create gradient colors based on position
  gradient_colors <- colorRampPalette(color_palette)(n - 1)

  # Set up empty plot area
  plot(x, ts_data, type = "n", ylab = ylab, xlab = xlab, main = main)

  # Draw gradient line segments
  for (i in 1:(n - 1)) {
    segments(x[i], ts_data[i], x[i + 1], ts_data[i + 1], col = gradient_colors[i], lwd = 2)
  }
}
X[] <- lapply(X, as.numeric)
X.ts <- ts(X)
Y.ts <- ts(Y)

# Reset to single plot for Y
par(mfrow = c(1, 1), mar = c(5, 5, 4, 2), oma = c(1, 0, 2, 0))

plot_gradient_ts(Y.ts[, "x2"], ylab = "Energy Output (MW)/Hourly (Net)", xlab = "Time Index", main = "x2: Output Variable (Y)", color_palette = c("cyan", "blue"))

```
```{r}
# Assuming your data is already loaded as X and Y
X[] <- lapply(X, as.numeric)
Y[] <- lapply(Y, as.numeric)

# Create time series objects
X.ts <- ts(X)
Y.ts <- ts(Y)

# Define custom colors for gradient
get_gradient_col <- function(color) {
  adjustcolor(color, alpha.f = 0.6)
}

# Open a larger plotting window
windows(width = 12, height = 8)  # Use quartz() on Mac or X11() on Linux

# Set layout: 2 rows and 2 columns (4 plots)
par(mfrow = c(2, 1),             # 2 stacked groups
    mar = c(6, 6, 5, 2),         # bottom, left, top, right
    oma = c(1, 1, 1, 1),         # outer margins
    cex.axis = 1.2,              # larger axis text
    cex.lab = 1.5,               # larger label text
    cex.main = 1.8)              # larger title

# Plot group 1: x1 and x3 stacked
plot(X.ts[, "x1"], type = "l", col = get_gradient_col("red"),
     ylab = "Temperature (°C)",
     xlab = "Time Index",
     main = expression(bold("x1: Temperature (T)")))

plot(X.ts[, "x3"], type = "l", col = get_gradient_col("blue"),
     ylab = "Pressure (millibar)",
     xlab = "Time Index",
     main = expression(bold("x3: Ambient Pressure (AP)")))

# Plot group 2: x4 and x5 stacked
plot(X.ts[, "x4"], type = "l", col = get_gradient_col("forestgreen"),
     ylab = "Humidity (%)",
     xlab = "Time Index",
     main = expression(bold("x4: Relative Humidity (RH)")))

plot(X.ts[, "x5"], type = "l", col = get_gradient_col("purple"),
     ylab = "Vacuum (cm Hg)",
     xlab = "Time Index",
     main = expression(bold("x5: Exhaust Vacuum (V)")))

# Reset layout for Y
par(mfrow = c(1, 1),
    mar = c(6, 6, 5, 2),
    oma = c(1, 1, 1, 1))

# Plot Y output
plot(Y.ts[, "x2"], type = "l", col = get_gradient_col("black"),
     ylab = "Energy Output (MW) / Hourly (Net)",
     xlab = "Time Index",
     main = expression(bold("x2: Output Variable (Y)")))



```


```{r}
# old code

X[] <- lapply(X, as.numeric)

X.ts <- ts(X)

par(mfrow = c(2, 1), 
    mar = c(1, 5, 3.5, 1),  
    oma = c(1, 1, 1, 0))   

# Plot each variable separately with appropriate labels
plot(X.ts[, 1], type = "l", col = "black",
     ylab = "Temperature (°C)",
     main = "x1: Temperature (T)")

plot(X.ts[, 2], type = "l", col = "black",
     ylab = "Pressure (millibar)",
     main = "x3: Ambient Pressure (AP)")

plot(X.ts[, 3], type = "l", col = "black",
     ylab = "Humidity (%)",
     main = "x4: Relative Humidity (RH)")

plot(X.ts[, 4], type = "l", col = "black",
     ylab = "Vacuum (cm Hg)",
     xlab = "Time Index",
     main = "x5: Exhaust Vacuum (V)")


# Reset to single plot layout for Y variable
par(mfrow = c(1, 1), 
    mar = c(5, 5, 4, 2),
    oma = c(1, 0, 2, 0))    

# Plot Y variable
plot(Y.ts, type = "l", col = "black",
     ylab = "Energy Output (MW)/Hourly(Net)",
     xlab = "Time Index",
     main = "x2: Output Variable (Y)")



```

# task 1.2 : Plotting distribution of given data set

# histogram and density plot of individual input signal X and output signal y
```{r}
# Helper function with customizable x-axis label
plot_gradient_hist_density <- function(data, var_name, main_title, density_color, xlab_label) {
  x <- data[, var_name]
  h <- hist(x, plot = FALSE, breaks = "Sturges")  # Compute histogram without plotting

  # Generate gradient colors
  n_bins <- length(h$counts)
  gradient_colors <- colorRampPalette(c("yellow", "red"))(n_bins)

  # Plot empty plot with correct axis limits
  plot(h, freq = FALSE, col = NA, border = NA, main = main_title, xlab = xlab_label)

  # Draw gradient bars
  for (i in 1:n_bins) {
    rect(h$breaks[i], 0, h$breaks[i + 1], h$density[i], col = gradient_colors[i], border = NA)
  }

  # Add density line
  lines(density(x), lwd = 2, col = density_color)

  # Add rug with jittered values
  rug(jitter(x))
}

# x1 - Temperature
plot_gradient_hist_density(X, "x1", "Histogram and density plot of Temperature (x1)", "red", "Input Signal: Temperature (°C)")

# x3 - Ambient Pressure
plot_gradient_hist_density(X, "x3", "Histogram and density plot of Ambient Pressure (x3)", "red", "Input Signal: Ambient Pressure (mbar)")

# x4 - Relative Humidity
plot_gradient_hist_density(X, "x4", "Histogram and density plot of Relative Humidity (x4)", "red", "Input Signal: Relative Humidity (%)")

# x5 - Exhaust Vacuum
plot_gradient_hist_density(X, "x5", "Histogram and density plot of Exhaust Vacuum (x5)", "red", "Input Signal: Exhaust Vacuum (cm Hg)")

# y - Energy Output
plot_gradient_hist_density(Y, "x2", "Histogram and density plot of Energy Output (y)", "blue", "Output Signal: Energy Output (PE)")

```
# Task 1.3: Plotting Scatterness to identify correlation
```{r}
length(X[,"x1"])
length(Y[,"x2"])
```
```{r}
# Function to create a scatter plot with correlation coefficient
create_scatter_plot <- function(x, y, x_var_name, title) {
  # Calculate Pearson correlation coefficient
  cor_val <- round(cor(x, y, use = "complete.obs"), 2)
  
  # Create data frame for ggplot
  data <- data.frame(x = x, y = y)
  
  # Generate scatter plot
  p <- ggplot(data, aes(x = x, y = y)) +
    geom_point(color = "orange", alpha = 0.6, size = 2) +  # Blue points with transparency
    #geom_smooth(method = "lm", color = "#ff7f0e", se = FALSE) +  # Add linear regression line
    labs(
      title = paste(title, "- Corr:", cor_val),
      x = paste(x_var_name, "Signal"),
      y = "Output Signal Y"
    ) +
    theme_minimal() +  # Clean theme
    theme(
      plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
      axis.title = element_text(size = 10),
      axis.text = element_text(size = 8)
    )
  
  return(p)
}

# Check if required variables exist
if (!exists("X") || !exists("Y")) {
  stop("Error: 'X' and/or 'Y' not found. Please define these variables.")
}

# Ensure X has the required columns
required_cols <- c("x1", "x3", "x4", "x5")
if (!all(required_cols %in% colnames(X))) {
  stop("Error: X must contain columns 'x1', 'x3', 'x4', 'x5'.")
}

# Create individual plots
p1 <- create_scatter_plot(X[, "x1"], Y[,"x2"], "X1", "Correlation in Temperature(x1) and Energy Output(x2)")
p3 <- create_scatter_plot(X[, "x3"], Y[,"x2"], "X3", "Correlation in Ambient Pressure(x3) and Energy Output(x2)")
p4 <- create_scatter_plot(X[, "x4"], Y[,"x2"], "X4", "Correlation in Relative Humidity(x4) and Energy Output(x2)")
p5 <- create_scatter_plot(X[, "x5"], Y[,"x2"], "X5", "Correlation in Exhaust Vacuum(x5) and Energy Output(x2)")

# Arrange plots in a 1x1 grid
grid.arrange(p1, ncol = 1, nrow = 1)
grid.arrange(p3, ncol = 1, nrow = 1)
grid.arrange(p4, ncol = 1, nrow = 1)
grid.arrange(p5, ncol = 1, nrow = 1)
```


# Data Normaliation and Addressing Multicollinearity
```{r}
# Function for Z-score normalization
zscore_normalize <- function(data) {
  return(scale(data))  # Built-in R function for Z-score
}
```
```{r}
# Apply Z-score normalization to features (X)
X_normalized <- zscore_normalize(X)
print("Z-score normalized X (first 5 rows):")
print(head(X_normalized, 5))

# Apply Z-score normalization to target variable (Y)
Y_normalized <- zscore_normalize(Y)
print("Z-score normalized Y (first 5 rows):")
print(head(Y_normalized, 5))

# ============================================
# MULTICOLLINEARITY CHECK
# ============================================

# Calculate correlation matrix
correlation_matrix <- cor(X_normalized)
print("Correlation Matrix:")
print(correlation_matrix)

# Check for high correlations (>0.8 or <-0.8)
high_corr <- which(abs(correlation_matrix) > 0.8 & correlation_matrix != 1, arr.ind = TRUE)
if(nrow(high_corr) > 0) {
  print("High correlations detected:")
  for(i in 1:nrow(high_corr)) {
    row_var <- rownames(correlation_matrix)[high_corr[i,1]]
    col_var <- colnames(correlation_matrix)[high_corr[i,2]]
    corr_value <- correlation_matrix[high_corr[i,1], high_corr[i,2]]
    print(paste(row_var, "vs", col_var, ":", round(corr_value, 3)))
  }
} else {
  print("No severe multicollinearity detected (threshold: 0.8)")
}

# ============================================
# VARIANCE INFLATION FACTOR (VIF) - Optional
# ============================================

# Install and load car package if not already installed
if(!require(car)) {
  install.packages("car")
  library(car)
}

# Create a data frame for VIF calculation
df_normalized <- data.frame(X_normalized, y = Y_normalized)

# Calculate VIF (values > 5 indicate multicollinearity)
tryCatch({
  model_for_vif <- lm(y ~ ., data = df_normalized)
  vif_values <- vif(model_for_vif)
  print("Variance Inflation Factors:")
  print(vif_values)
  print("Note: VIF > 5 indicates multicollinearity concern")
}, error = function(e) {
  print("VIF calculation failed - this might happen with perfect correlations")
})

print("Summary of normalized data:")
print("X variables:")
print(summary(X_normalized))
print("Y variable:")
print(summary(Y_normalized))

# Verify normalization worked (means should be ~0, std should be ~1)
print("Verification - Means (should be ~0):")
print(colMeans(X_normalized))
print(paste("Y mean:", mean(Y_normalized)))

print("Verification - Standard deviations (should be ~1):")
print(apply(X_normalized, 2, sd))
print(paste("Y std:", sd(Y_normalized)))


```





